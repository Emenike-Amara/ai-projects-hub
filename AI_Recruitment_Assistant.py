# -*- coding: utf-8 -*-
"""
hring app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qmc7bH8mPn6N4QNu24PUPHPpMXNkxvmG
"""
import os
from dotenv import load_dotenv

load_dotenv()  # loads the .env file
import json
import streamlit as st
import google.generativeai as genai
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import smtplib
import io
from PyPDF2 import PdfReader
import math
# Load the API key from environment variables
API_KEY = os.getenv("API_KEY")


# # ==============================================================================
# #  STEP 1: CONFIGURE THE APP and AI MODEL
# # ==============================================================================

# # --- Page Config ---
# # MUST be the first Streamlit command in your script
st.set_page_config(
    page_title="AI Recruitment Assistant",
    page_icon="ü§ñ",
    layout="wide",  # 'wide' layout uses the full screen width
    initial_sidebar_state="expanded", # Optional: collapse sidebar by default
)

# # --- API Key Configuration ---
if API_KEY == "YOUR_API_KEY_HERE" or not API_KEY:
    st.error("üî¥ Error: Please replace 'YOUR_API_KEY_HERE' with your actual API key.") #exception
else:
    try:
        genai.configure(api_key=API_KEY)
        # st.success("‚úÖ API Key configured successfully.") # Optional: can be commented out for a cleaner UI
    except Exception as e:
        st.error(f"An error occurred during API key configuration: {e}")

# ==============================================================================
#  HELPER FUNCTION TO EXTRACT TEXT FROM UPLOADED FILES
# ==============================================================================

def extract_text_from_file(uploaded_file):
    """
    Extracts text from an uploaded file (supports .txt and .pdf).
    """
    if uploaded_file.name.endswith('.pdf'):
        try:
            pdf_reader = PdfReader(io.BytesIO(uploaded_file.getvalue()))
            text = ""
            for page in pdf_reader.pages:
                text += page.extract_text()
            return text
        except Exception as e:
            st.error(f"Error reading PDF {uploaded_file.name}: {e}")
            return None
    elif uploaded_file.name.endswith('.txt'):
        return uploaded_file.getvalue().decode("utf-8")
    else:
        st.warning(f"Unsupported file format for {uploaded_file.name}. Only .txt and .pdf are supported.")
        return None

# ==============================================================================
#  AI SERVICE FUNCTIONS (with Streamlit Caching for performance)
# ==============================================================================

@st.cache_data
def generate_text_embedding(text_content: str, task: str = "RETRIEVAL_DOCUMENT") -> list[float]:
    """Generates a text embedding for a given piece of text."""
    try:
        result = genai.embed_content(
            model="models/embedding-001",
            content=text_content,
            task_type=task
        )
        return result.get('embedding', [])
    except Exception as e:
        st.error(f"An error occurred during embedding generation: {e}")
        return []

@st.cache_data
def generate_assessment_questions(job_description: str, num_questions: int = 5) -> str:
    """Generates assessment questions based on a job description."""
    try:
        model = genai.GenerativeModel('gemini-1.5-flash')
        prompt = f"""
        Based on the following job description, please generate {num_questions} relevant assessment questions for a candidate.
        --- Job Description ---
        {job_description}
        --- End of Job Description ---
        Please provide the questions in a clear, numbered list.
        """
        response = model.generate_content(prompt)
        return response.text
    except Exception as e:
        st.error(f"An error occurred during question generation: {e}")
        return "An error occurred. Please check the terminal for more details."

def score_assessment_answers(_job_description: str, _candidate_answers: str) -> dict:
    """Scores a candidate's CV or answers against a job description."""
    print(f"Scoring content against job description...") # Log to terminal
    try:
        model = genai.GenerativeModel('gemini-1.5-flash')
        prompt = f"""
        You are an expert technical recruiter. Evaluate the candidate's CV or answers based on the provided job description.
        Provide your evaluation in a valid JSON format with the following keys: "overall_score" (an integer from 1-10), "summary" (a string), "strengths" (a string with bullet points), "weaknesses" (a string with bullet points), and "final_recommendation" (a string).
        Do not include any text, code block formatting like ```json, or markdown before or after the JSON object.

        **Job Description:**
        ---
        {_job_description}
        ---

        **Candidate's CV / Answers:**
        ---
        {_candidate_answers}
        ---
        """
        response = model.generate_content(prompt)
        # It's safer to clean the text in case the model unexpectedly adds markdown
        cleaned_text = response.text.strip().lstrip("```json").rstrip("```")
        return json.loads(cleaned_text)
    except Exception as e:
        st.error(f"An error occurred during scoring: {e}")
        # To aid in debugging, you might want to see the raw response
        st.error(f"Raw model response: {response.text if 'response' in locals() else 'No response object'}")
        return {"error": "An error occurred. Please check the Streamlit terminal for more details."}


# ==============================================================================
#  NEW FUNCTION TO SEND AUTOMATED EMAILS
# ==============================================================================

def send_interview_email(recipient_email, candidate_name, job_title, calendly_link, sender_email, sender_password):
    """
    Sends an automated interview invitation email to the candidate.
    """
    try:
        # Email configuration
        smtp_server = "smtp.gmail.com"
        smtp_port = 587
        
        # Email content
        subject = f"Invitation to Interview for {job_title} position"
        body = f"""Dear {candidate_name},

Thank you for your interest in the {job_title} position. We were very impressed with your background and would like to invite you to an interview to discuss your application further.

Please use the following link to schedule a time that is convenient for you:
{calendly_link}

We look forward to speaking with you soon.

Best regards,
The Hiring Team
"""
        
        # Create the email
        msg = MIMEMultipart()
        msg['From'] = sender_email
        msg['To'] = recipient_email
        msg['Subject'] = subject
        msg.attach(MIMEText(body, 'plain'))
        
        # Connect to the server and send the email
        server = smtplib.SMTP(smtp_server, smtp_port)
        server.starttls()
        server.login(sender_email, sender_password)
        server.send_message(msg)
        server.quit()
        
        st.success(f"Successfully sent interview invitation to {recipient_email}")
        
    except Exception as e:
        st.error(f"Failed to send email to {recipient_email}. Error: {e}")
# </mark>


# ==============================================================================
#  STEP 2: CUSTOM CSS FOR SIDEBAR DASHBOARD DESIGN
#  (EDIT COLORS AND STYLES HERE)
# ==============================================================================

st.markdown("""
<style>
    /* Main page background */
    .main .block-container {
        background-color: #FDFAF6;
        padding-top: 3rem;
        padding-bottom: 3rem;
    }

    /* Sidebar styles */
    [data-testid="stSidebar"] {
        background-color: #819A91; /* Slate blue from the image */
        padding-top: 2rem;
    }

    /* Sidebar header */
    [data-testid="stSidebar"] h2 {
        color: white;
        padding-left: 1rem;
        font-weight: 600;
    }
            
    /* Sidebar navigation (radio buttons) */
    div[data-baseweb="radio"] > label > div:first-child {
        /* Hide the radio button circle */
        display: none;
    }
            
    div[data-baseweb="radio"] > label {
        /* General style for all radio labels */
        display: flex !important;
        align-items: center;
        padding: 0.75rem 1rem;
        border-radius: 8px;
        margin-bottom: 0.5rem;
        color: #FDFAF6; /* Lighter text color for inactive items */
        transition: background-color 0.2s ease-in-out;
    }
            
    div[data-baseweb="radio"] > label:hover {
        /* Hover effect */
        background-color: #FDFAF6;
        color: white;
    }

    /* Style for the SELECTED radio button label */
    div[data-testid='stRadio'] > label[data-in-use='true'] {
        background-color: #2a344d; /* Darker blue for active selection */
        color: white;
        font-weight: 600;
        border-right: 5px solid #6b82d8; /* Highlight bar */
    }

            
    /* Style for the card headers */
    .card h3 {
        font-size: 1.75em;
        color: #31333F;
        font-weight: 600;
        margin-bottom: 20px;
    }

    /* Hiding Streamlit's default elements */
    #MainMenu {visibility: hidden;}
    footer {visibility: hidden;}
    header {visibility: hidden;}
</style>
""", unsafe_allow_html=True)

# ==============================================================================
#  STEP 4: SIDEBAR NAVIGATION
# ==============================================================================

with st.sidebar:
    st.markdown("<h2>AI SERVICES FOR HIRING</h2>", unsafe_allow_html=True)

    # Use a radio button as a navigation menu. The icons are emojis.
    selected_page = st.radio(
        "Services",
        ["üìù Assessment Generator", "üìä Automated CV Scorer"],
        label_visibility="hidden" # Hides the "Services" label above the radio buttons
    )

    # You can add more sections to the sidebar here if needed
    st.markdown("---")
    st.info("Created by Precious Emenike")


# Display the content of the selected page inside a styled card
st.markdown('<div class="card">', unsafe_allow_html=True)

if selected_page == "üìù Assessment Generator":
    st.markdown("<h3>üìù Assessment Generator</h3>", unsafe_allow_html=True)
    st.markdown("Paste a job description to automatically generate relevant interview questions.")

    jd_for_questions = st.text_area(
        "**Job Description**",
        height=300,
        key="jd_questions",
        placeholder="e.g., Seeking a Python developer with experience in data science..."
    )

    if st.button("Generate Questions", type="primary", use_container_width=True):
        if jd_for_questions and API_KEY != "YOUR_API_KEY_HERE":
            with st.spinner("üß† Thinking up some insightful questions..."):
                questions = generate_assessment_questions(jd_for_questions)
                st.subheader("Generated Questions")
                st.markdown(questions)
        # ... (rest of the button logic)

elif selected_page == "üìä Automated CV Scorer":
    st.markdown("<h3>üìä Automated CV Scorer</h3>", unsafe_allow_html=True)
    st.markdown("Provide a job description and upload CVs for automated scoring and ranking.")

    # Initialize session state to store the ranking results
    if 'results' not in st.session_state:
        st.session_state.results = None

    jd_for_scoring = st.text_area(
        "**Job Description**",
        height=200,
        key="jd_scoring",
        placeholder="Paste the job description here."
    )

    # Add job title input right after job description
    job_title_global = st.text_input(
    "**Job Title**",
    key="global_job_title",
    placeholder="e.g., Senior Python Developer, Data Analyst, etc.",
    value=" "
    )

    uploaded_files = st.file_uploader(
        "**Upload CVs (.PDF or .TXT)**",
        type=["pdf", "txt"],
        accept_multiple_files=True,
        key="cv_uploader"
    )
    
    if uploaded_files:
        top_n_percentage = st.slider(
            "**Select Top % of Applicants to Display**",
            min_value=1,
            max_value=100,
            value=25,
            step=1,
            key="top_n_slider"
        )

    # Use columns for the buttons
    col1, col2 = st.columns(2)

    with col1:
        if st.button("Rank All Uploaded CVs", type="primary", use_container_width=True):
                if jd_for_scoring and uploaded_files:
                    with st.spinner(f"Evaluating {len(uploaded_files)} CV(s)... This may take a moment."):
                        results = []
                        for uploaded_file in uploaded_files:
                            cv_text = extract_text_from_file(uploaded_file)
                            if cv_text:
                                score_data = score_assessment_answers(jd_for_scoring, cv_text)
                                if "error" not in score_data:
                                    score_data['filename'] = uploaded_file.name
                                    results.append(score_data)
                                else:
                                    st.error(f"Could not process {uploaded_file.name}. Error: {score_data['error']}")

                        if results:
                            # Sort results by overall_score in descending order
                            sorted_results = sorted(results, key=lambda x: x.get('overall_score', 0), reverse=True)
                            
                            # Save the sorted results to the session state
                            st.session_state.results = sorted_results

                else:
                    st.warning("Please provide a job description and upload at least one CV.")

    with col2:
        # Add a button to clear the results and reset the state
        if st.button("Clear Results", use_container_width=True):
            st.session_state.results = None
            st.rerun() # Use rerun to immediately clear the display

    # This block now runs INDEPENDENTLY of the button click.
    # It will display results as long as they exist in the session state.
    if st.session_state.results:
        st.success("‚úÖ Evaluation Complete. See the ranked results below.")
        
        # Calculate the number of top applicants to display
        num_to_display = math.ceil(len(st.session_state.results) * (top_n_percentage / 100))
        
        st.markdown(f"---")
        st.info(f"Displaying top **{num_to_display}** candidate(s) based on your selection.")
        st.markdown(f"---")

        # Display only the top N% of applicants from session state
        for i, result in enumerate(st.session_state.results[:num_to_display]):
            st.subheader(f"Rank {i+1}: {result['filename']} | Score: {result.get('overall_score', 'N/A')}/10")
            st.markdown(f"**üìå Recommendation:** {result.get('final_recommendation', 'N/A')}")
            
            with st.expander("Show Detailed Analysis"):
                st.markdown(f"**üìÑ Summary:** {result.get('summary', 'N/A')}")
                st.markdown(f"**üëç Strengths:**")
                st.markdown(result.get('strengths', 'N/A'))
                st.markdown(f"**üëé Weaknesses:**")
                st.markdown(result.get('weaknesses', 'N/A'))

            # <mark>
            # --- REVISED AUTOMATED EMAIL SECTION ---
            # Using st.form to group inputs and prevent app from resetting
            st.markdown(f"#### Send Interview Invitation to {result['filename']}")
            
            # Each candidate gets their own form to keep their data separate
            with st.form(key=f"email_form_{i}"):
                st.markdown("**Fill out all fields to send invitation:**")
                
                # Use columns within the form for better layout
                form_col1, form_col2 = st.columns(2)
                
                with form_col1:
                    candidate_name = st.text_input("Candidate's Full Name", key=f"name_{i}")
                    candidate_email = st.text_input("Candidate's Email Address", key=f"email_{i}")
                    calendly_link = st.text_input("Your Calendly Link", key=f"calendly_{i}", value="https://calendly.com/your-link")

                with form_col2:
                    # For security, using secrets is highly recommended for a real app
                    sender_email = st.text_input("Your Email (e.g., Gmail)", key=f"sender_email_{i}")
                    sender_password = st.text_input("Your Email Password", type="password", key=f"sender_password_{i}")
                    st.caption("Note: For Gmail, you may need to use an 'App Password'.")
                
                # The submit button for the form
                submitted = st.form_submit_button("Send Invitation Email")

                # This logic now ONLY runs when the 'submitted' button is pressed
                if submitted:
                    if all([candidate_email, candidate_name, calendly_link, sender_email, sender_password]):
                        with st.spinner(f"Sending email to {candidate_name}..."):
                            send_interview_email(
                                recipient_email=candidate_email,
                                candidate_name=candidate_name,
                                job_title=job_title_global, 
                                calendly_link=calendly_link,
                                sender_email=sender_email,
                                sender_password=sender_password
                            )
                    else:
                        st.warning("Please fill in all the fields within the form before sending.", icon="‚ö†Ô∏è")
            
            st.markdown("---")
            # </mark>
        else:
            st.warning("Please provide a job description and upload at least one CV.")
